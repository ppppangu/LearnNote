# 第七部分：框架特定语法

> 本章介绍 Next.js、Prisma、Zod 等框架的特定语法

---

## 1. Next.js App Router

Next.js 是一个基于 React 的全栈框架，提供路由、API、SSR 等功能。

### 文件路由系统

```
app/
├── page.tsx              → /（首页）
├── layout.tsx            → 布局组件
├── about/
│   └── page.tsx          → /about
├── blog/
│   ├── page.tsx          → /blog
│   └── [slug]/
│       └── page.tsx      → /blog/:slug（动态路由）
└── api/
    ├── users/
    │   └── route.ts      → /api/users（API 路由）
    └── pricing/
        └── route.ts      → /api/pricing
```

### 项目的路由结构

```
open-nof1.ai/app/
├── page.tsx                              → / 主页
├── layout.tsx                            → 全局布局
├── globals.css                           → 全局样式
└── api/
    ├── cron/
    │   ├── 20-seconds-metrics-interval/
    │   │   └── route.ts                  → /api/cron/20-seconds-metrics-interval
    │   └── 3-minutes-run-interval/
    │       └── route.ts                  → /api/cron/3-minutes-run-interval
    ├── metrics/
    │   └── route.ts                      → /api/metrics
    ├── model/
    │   └── chat/
    │       └── route.ts                  → /api/model/chat
    └── pricing/
        └── route.ts                      → /api/pricing
```

### 页面组件（page.tsx）

```tsx
// app/page.tsx - 页面组件

// 服务器组件（默认）
export default function HomePage() {
    return <h1>首页</h1>;
}

// 客户端组件
"use client";

export default function HomePage() {
    const [data, setData] = useState(null);
    return <h1>首页</h1>;
}

// 项目示例：来自 open-nof1.ai/app/page.tsx
"use client";

import { useEffect, useState, useCallback } from "react";
// ...

export default function Home() {
    const [metricsData, setMetricsData] = useState<MetricData[]>([]);
    // ...

    return (
        <div className="min-h-screen bg-background p-4 md:p-8">
            {/* 页面内容 */}
        </div>
    );
}
```

### 布局组件（layout.tsx）

```tsx
// app/layout.tsx - 根布局

import type { Metadata } from "next";

// 页面元数据（SEO）
export const metadata: Metadata = {
    title: "My App",
    description: "App description",
};

// 布局组件包裹所有页面
export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="en">
            <body>{children}</body>
        </html>
    );
}

// 项目示例：来自 open-nof1.ai/app/layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
    variable: "--font-geist-sans",
    subsets: ["latin"],
});

export const metadata: Metadata = {
    title: "Create Next App",
    description: "Generated by create next app",
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="en">
            <body
                className={`${geistSans.variable} ${geistMono.variable} antialiased`}
            >
                {children}
            </body>
        </html>
    );
}
```

### API 路由（Route Handlers）

```tsx
// app/api/example/route.ts

import { NextRequest, NextResponse } from "next/server";

// GET 请求
export async function GET(request: NextRequest) {
    const data = { message: "Hello" };
    return NextResponse.json(data);
}

// POST 请求
export async function POST(request: NextRequest) {
    const body = await request.json();
    return NextResponse.json({ received: body });
}

// 获取查询参数
export async function GET(request: NextRequest) {
    const url = new URL(request.url);
    const id = url.searchParams.get("id");
    return NextResponse.json({ id });
}

// 返回错误
export async function GET() {
    return NextResponse.json(
        { error: "Not found" },
        { status: 404 }
    );
}
```

### 项目中的 API 路由示例

```tsx
// 来自 open-nof1.ai/app/api/pricing/route.ts

import { NextResponse } from "next/server";
import { getCurrentMarketState } from "@/lib/trading/current-market-state";

export const GET = async () => {
    try {
        // 并行获取多个加密货币价格
        const [btcPricing, ethPricing, solPricing, dogePricing, bnbPricing] =
            await Promise.all([
                getCurrentMarketState("BTC/USDT"),
                getCurrentMarketState("ETH/USDT"),
                getCurrentMarketState("SOL/USDT"),
                getCurrentMarketState("DOGE/USDT"),
                getCurrentMarketState("BNB/USDT"),
            ]);

        return NextResponse.json({
            data: {
                pricing: { btc: btcPricing, eth: ethPricing, ... },
            },
            success: true,
        });
    } catch (error) {
        console.error("Error fetching pricing:", error);
        return NextResponse.json(
            { error: "Failed to fetch pricing data", success: false },
            { status: 500 }
        );
    }
};

// 来自 open-nof1.ai/app/api/cron/3-minutes-run-interval/route.ts

import { run } from "@/lib/ai/run";
import { NextRequest } from "next/server";
import jwt from "jsonwebtoken";

export const GET = async (request: NextRequest) => {
    // 获取查询参数
    const url = new URL(request.url);
    const token = url.searchParams.get("token");

    if (!token) {
        return new Response("Token is required", { status: 400 });
    }

    try {
        // JWT 验证
        jwt.verify(token, process.env.CRON_SECRET_KEY || "");
    } catch (error) {
        return new Response("Invalid token", { status: 401 });
    }

    // 执行业务逻辑
    await run(Number(process.env.START_MONEY));

    return new Response("Process executed successfully");
};

// 来自 open-nof1.ai/app/api/model/chat/route.ts

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { ModelType } from "@prisma/client";

export const GET = async (request: NextRequest) => {
    // 数据库查询
    const chat = await prisma.chat.findMany({
        where: {
            model: ModelType.Deepseek,
        },
        take: 10,
        orderBy: {
            createdAt: "desc",
        },
        include: {
            tradings: {
                take: 10,
                orderBy: {
                    createdAt: "desc",
                },
            },
        },
    });

    return NextResponse.json({
        data: chat,
    });
};
```

---

## 2. Prisma ORM

Prisma 是一个类型安全的数据库 ORM，支持 PostgreSQL、MySQL、SQLite 等。

### Schema 定义

```prisma
// prisma/schema.prisma

// 数据库配置
generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// 模型定义（对应数据库表）
model User {
    id        String   @id @default(uuid())
    email     String   @unique
    name      String?
    posts     Post[]   // 一对多关系
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Post {
    id       String @id @default(uuid())
    title    String
    content  String
    author   User   @relation(fields: [authorId], references: [id])
    authorId String
}
```

### 项目的 Prisma Schema

```prisma
// 来自 open-nof1.ai/prisma/schema.prisma

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// 指标数据模型
model Metrics {
    id String @id @default(uuid())

    name    String
    model   ModelType
    metrics Json[]      // JSON 数组

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// AI 聊天记录模型
model Chat {
    id String @id @default(uuid())

    model      ModelType @default(Deepseek)
    chat       String    @default("<no chat>")
    reasoning  String
    userPrompt String
    tradings   Trading[]  // 一对多关系

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// 交易记录模型
model Trading {
    id String @id @default(uuid())

    symbol     Symbol
    opeartion  Opeartion
    leverage   Int?
    amount     Int?
    pricing    Int?
    stopLoss   Int?
    takeProfit Int?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    Chat   Chat?   @relation(fields: [chatId], references: [id], onDelete: Cascade)
    chatId String?
}

// 枚举类型
enum Opeartion {
    Buy
    Sell
    Hold
}

enum Symbol {
    BTC
    ETH
    BNB
    SOL
    DOGE
}

enum ModelType {
    Deepseek
    DeepseekThinking
    Qwen
    Doubao
}
```

### Prisma 客户端使用

```tsx
// 初始化 Prisma 客户端
// 来自 open-nof1.ai/lib/prisma.ts

import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient();
```

### CRUD 操作

```tsx
import { prisma } from "@/lib/prisma";

// 【创建】
const user = await prisma.user.create({
    data: {
        email: "test@example.com",
        name: "张三",
    },
});

// 【查询单个】
const user = await prisma.user.findUnique({
    where: { id: "xxx" },
});

// 【查询多个】
const users = await prisma.user.findMany({
    where: { name: { contains: "张" } },
    orderBy: { createdAt: "desc" },
    take: 10,
});

// 【更新】
const updated = await prisma.user.update({
    where: { id: "xxx" },
    data: { name: "新名字" },
});

// 【删除】
await prisma.user.delete({
    where: { id: "xxx" },
});

// 【关系查询】
const userWithPosts = await prisma.user.findUnique({
    where: { id: "xxx" },
    include: { posts: true },  // 包含关联的 posts
});
```

### 项目中的 Prisma 使用示例

```tsx
// 来自 open-nof1.ai/lib/ai/run.ts

// 创建聊天记录和关联的交易
await prisma.chat.create({
    data: {
        reasoning: reasoning || "<no reasoning>",
        chat: object.chat || "<no chat>",
        userPrompt,
        tradings: {
            createMany: {
                data: {
                    symbol: Symbol.BTC,
                    opeartion: object.opeartion,
                    pricing: object.buy?.pricing,
                    amount: object.buy?.amount,
                    leverage: object.buy?.leverage,
                },
            },
        },
    },
});

// 查询计数
const invocationCount = await prisma.chat.count();

// 来自 open-nof1.ai/app/api/cron/20-seconds-metrics-interval/route.ts

// 查询或创建
let existMetrics = await prisma.metrics.findFirst({
    where: {
        model: ModelType.Deepseek,
    },
});

if (!existMetrics) {
    existMetrics = await prisma.metrics.create({
        data: {
            name: "20-seconds-metrics",
            metrics: [],
            model: ModelType.Deepseek,
        },
    });
}

// 更新
await prisma.metrics.update({
    where: {
        id: existMetrics?.id,
    },
    data: {
        metrics: finalMetrics as InputJsonValue[],
    },
});

// 来自 open-nof1.ai/app/api/model/chat/route.ts

// 复杂查询：包含关系和排序
const chat = await prisma.chat.findMany({
    where: {
        model: ModelType.Deepseek,
    },
    take: 10,
    orderBy: {
        createdAt: "desc",
    },
    include: {
        tradings: {
            take: 10,
            orderBy: {
                createdAt: "desc",
            },
        },
    },
});
```

### 类型导入

```tsx
// Prisma 自动生成类型
import { User, Post, Prisma } from "@prisma/client";
import { ModelType, Symbol, Opeartion } from "@prisma/client";

// 使用生成的类型
const user: User = await prisma.user.findUnique({ where: { id } });

// 使用枚举
if (object.opeartion === Opeartion.Buy) {
    // ...
}

// JSON 类型
import { InputJsonValue, JsonValue } from "@prisma/client/runtime/library";

const newMetrics = [...oldMetrics, newItem] as JsonValue[];
```

---

## 3. Zod 验证库

Zod 是一个 TypeScript 优先的 schema 声明和验证库。

### 基础用法

```tsx
import { z } from "zod";

// 定义 schema
const userSchema = z.object({
    name: z.string(),
    age: z.number().min(0).max(150),
    email: z.string().email(),
});

// 推断 TypeScript 类型
type User = z.infer<typeof userSchema>;
// { name: string; age: number; email: string }

// 验证数据
const result = userSchema.safeParse({
    name: "张三",
    age: 25,
    email: "test@example.com",
});

if (result.success) {
    console.log(result.data);  // 验证通过的数据
} else {
    console.log(result.error);  // 验证错误
}

// 直接解析（失败时抛出异常）
const user = userSchema.parse(data);
```

### 常用 Schema 类型

```tsx
import { z } from "zod";

// 基础类型
z.string()
z.number()
z.boolean()
z.null()
z.undefined()
z.any()

// 字符串验证
z.string().min(1)           // 最小长度
z.string().max(100)         // 最大长度
z.string().email()          // 邮箱格式
z.string().url()            // URL 格式
z.string().regex(/pattern/) // 正则匹配

// 数字验证
z.number().min(0)           // 最小值
z.number().max(100)         // 最大值
z.number().int()            // 整数
z.number().positive()       // 正数

// 对象
z.object({
    name: z.string(),
    age: z.number(),
})

// 数组
z.array(z.string())         // 字符串数组
z.array(z.number()).min(1)  // 至少一个元素

// 可选
z.string().optional()       // string | undefined

// 默认值
z.string().default("默认")

// 字面量
z.literal("success")        // 只能是 "success"

// 联合类型
z.union([z.string(), z.number()])

// 枚举
z.enum(["small", "medium", "large"])

// 原生枚举
enum Status { Active, Inactive }
z.nativeEnum(Status)
```

### 项目中的 Zod 使用

```tsx
// 来自 open-nof1.ai/lib/ai/run.ts

import { z } from "zod";
import { Opeartion } from "@prisma/client";

// 定义 AI 输出的 schema
const tradingSchema = z.object({
    // 使用 Prisma 枚举
    opeartion: z.nativeEnum(Opeartion),

    // 可选的买入参数
    buy: z
        .object({
            pricing: z.number().describe("The pricing of you want to buy in."),
            amount: z.number(),
            leverage: z.number().min(1).max(20),
        })
        .optional()
        .describe("If opeartion is buy, generate object"),

    // 可选的卖出参数
    sell: z
        .object({
            percentage: z
                .number()
                .min(0)
                .max(100)
                .describe("Percentage of position to sell"),
        })
        .optional()
        .describe("If opeartion is sell, generate object"),

    // 可选的止盈止损调整
    adjustProfit: z
        .object({
            stopLoss: z
                .number()
                .optional()
                .describe("The stop loss of you want to set."),
            takeProfit: z
                .number()
                .optional()
                .describe("The take profit of you want to set."),
        })
        .optional()
        .describe("If opeartion is hold and you want to adjust the profit, generate object"),

    // AI 的解释
    chat: z
        .string()
        .describe("The reason why you do this operation..."),
});

// 与 AI SDK 结合使用
const { object, reasoning } = await generateObject({
    model: deepseekR1,
    system: tradingPrompt,
    prompt: userPrompt,
    output: "object",
    mode: "json",
    schema: tradingSchema,  // 使用 Zod schema
});

// object 的类型自动推断为 z.infer<typeof tradingSchema>
```

### Zod + AI SDK

```tsx
import { generateObject } from "ai";
import { z } from "zod";

// 定义输出结构
const responseSchema = z.object({
    summary: z.string().describe("Summary of the analysis"),
    sentiment: z.enum(["bullish", "bearish", "neutral"]),
    confidence: z.number().min(0).max(100),
});

// AI 生成结构化输出
const { object } = await generateObject({
    model: someModel,
    prompt: "Analyze the market...",
    schema: responseSchema,
});

// object 类型是 { summary: string; sentiment: "bullish" | "bearish" | "neutral"; confidence: number }
console.log(object.summary);
console.log(object.sentiment);
console.log(object.confidence);
```

---

## 4. CCXT 交易库

CCXT 是一个统一的加密货币交易所 API 库。

### 初始化

```tsx
// 来自 open-nof1.ai/lib/trading/binance.ts

import ccxt from "ccxt";

export const binance = new ccxt.binance({
    apiKey: process.env.BINANCE_API_KEY,
    secret: process.env.BINANCE_API_SECRET,
    options: {
        defaultType: "future",  // 使用期货
    },
});

// 设置沙盒模式（测试环境）
binance.setSandboxMode(process.env.BINANCE_USE_SANDBOX === "true");
```

### 常用操作

```tsx
// 获取 OHLCV 数据（K线）
const ohlcv = await binance.fetchOHLCV(
    "BTC/USDT",  // 交易对
    "1m",        // 时间周期
    undefined,   // 起始时间
    100          // 数量
);
// 返回: [[timestamp, open, high, low, close, volume], ...]

// 获取持仓信息
const positions = await binance.fetchPositions(["BTC/USDT"]);

// 获取余额
const balance = await binance.fetchBalance({ type: "future" });
const usdtBalance = balance.USDT.total;
const availableBalance = balance.USDT.free;

// 获取持仓量
const openInterest = await binance.fetchOpenInterest("BTCUSDT");

// 获取资金费率
const fundingRate = await binance.fetchFundingRate("BTC/USDT");
```

### 项目中的 CCXT 使用

```tsx
// 来自 open-nof1.ai/lib/trading/current-market-state.ts

export async function getCurrentMarketState(
    symbol: string
): Promise<MarketState> {
    const normalizedSymbol = symbol.includes("/") ? symbol : `${symbol}/USDT`;

    // 获取 1 分钟和 4 小时 K 线数据
    const ohlcv1m = await binance.fetchOHLCV(normalizedSymbol, "1m", undefined, 100);
    const ohlcv4h = await binance.fetchOHLCV(normalizedSymbol, "4h", undefined, 100);

    // 提取收盘价
    const closes1m = ohlcv1m.map((candle) => Number(candle[4]));
    const closes4h = ohlcv4h.map((candle) => Number(candle[4]));

    // 计算技术指标...

    // 获取持仓量和资金费率
    try {
        const openInterest = await binance.fetchOpenInterest(perpSymbol);
        const fundingRates = await binance.fetchFundingRate(normalizedSymbol);
        // ...
    } catch (error) {
        console.warn("Could not fetch open interest or funding rate:", error);
    }

    return marketState;
}

// 来自 open-nof1.ai/lib/trading/account-information-and-performance.ts

export async function getAccountInformationAndPerformance(
    initialCapital: number
): Promise<AccountInformationAndPerformance> {
    // 获取持仓
    const positions = await binance.fetchPositions(["BTC/USDT"]);

    // 计算持仓价值
    const currentPositionsValue = positions.reduce((acc, position) => {
        return acc + (position.initialMargin || 0) + (position.unrealizedPnl || 0);
    }, 0);

    // 获取账户余额
    const currentCashValue = await binance.fetchBalance({ type: "future" });
    const totalCashValue = currentCashValue.USDT.total || 0;
    const availableCash = currentCashValue.USDT.free || 0;

    return {
        currentPositionsValue,
        contractValue,
        totalCashValue,
        availableCash,
        currentTotalReturn,
        positions,
        sharpeRatio,
    };
}
```

---

## 5. 技术指标库

```tsx
// 来自 open-nof1.ai/lib/trading/current-market-state.ts

import { EMA, MACD, RSI, ATR } from "technicalindicators";

// 计算 EMA（指数移动平均）
function calculateEMA(values: number[], period: number): number[] {
    const emaValues = EMA.calculate({ values, period });
    return emaValues;
}

// 计算 MACD
function calculateMACD(
    values: number[],
    fastPeriod = 12,
    slowPeriod = 26,
    signalPeriod = 9
): number[] {
    const macdValues = MACD.calculate({
        values,
        fastPeriod,
        slowPeriod,
        signalPeriod,
        SimpleMAOscillator: false,
        SimpleMASignal: false,
    });
    return macdValues.map((v) => v.MACD || 0);
}

// 计算 RSI（相对强弱指数）
function calculateRSI(values: number[], period: number): number[] {
    const rsiValues = RSI.calculate({ values, period });
    return rsiValues;
}

// 计算 ATR（平均真实范围）
function calculateATR(
    high: number[],
    low: number[],
    close: number[],
    period: number
): number[] {
    const atrValues = ATR.calculate({ high, low, close, period });
    return atrValues;
}
```

---

## 6. AI SDK

Vercel AI SDK 提供统一的 AI 模型接口。

```tsx
// 来自 open-nof1.ai/lib/ai/model.ts

import { createDeepSeek } from "@ai-sdk/deepseek";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";

// 创建 DeepSeek 客户端
const deepseekModel = createDeepSeek({
    apiKey: process.env.DEEPSEEK_API_KEY,
});

// 创建 OpenRouter 客户端
const openrouter = createOpenRouter({
    apiKey: process.env.OPENROUTER_API_KEY,
});

// 导出不同的模型
export const deepseekv31 = openrouter("deepseek/deepseek-v3.2-exp");
export const deepseekR1 = openrouter("deepseek/deepseek-r1-0528");
export const deepseek = deepseekModel("deepseek-chat");
export const deepseekThinking = deepseekModel("deepseek-reasoner");

// 使用 generateObject 生成结构化输出
// 来自 open-nof1.ai/lib/ai/run.ts

import { generateObject } from "ai";

const { object, reasoning } = await generateObject({
    model: deepseekR1,
    system: tradingPrompt,      // 系统提示
    prompt: userPrompt,         // 用户提示
    output: "object",
    mode: "json",
    schema: tradingSchema,      // Zod schema
});

// object 是结构化的输出
// reasoning 是模型的推理过程（如果支持）
```

---

## 小结

本章介绍了项目使用的主要框架和库：

| 框架/库 | 用途 | 关键特性 |
|--------|------|---------|
| **Next.js** | React 全栈框架 | App Router、API Routes、SSR |
| **Prisma** | 数据库 ORM | 类型安全、Schema 定义、关系查询 |
| **Zod** | 数据验证 | Schema 定义、类型推断、AI SDK 集成 |
| **CCXT** | 交易所 API | 统一接口、多交易所支持 |
| **AI SDK** | AI 模型集成 | 多模型支持、结构化输出 |

**关键要点：**
1. Next.js 的文件路由简化了路由配置
2. Prisma 提供类型安全的数据库操作
3. Zod 在运行时验证数据，与 TypeScript 类型系统互补
4. CCXT 统一了不同交易所的 API
5. AI SDK + Zod 实现可靠的 AI 结构化输出

下一章我们将通过项目实战来综合运用这些知识。
